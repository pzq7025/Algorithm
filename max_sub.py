# 计算连续最大子数组之和  强大的动态规划
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
for i in range(1, len(nums)):
    nums[i] += max(nums[i - 1], 0)
    # 如果前一个的值大于0则累加 同时替换当前的位置
    # [-2, 1, -3, 4, -1, 2, 1, -5, 4]
    # [-2, 1, -2, 4, -1, 2, 1, -5, 4]
    # [-2, 1, -2, 4, -1, 2, 1, -5, 4]
    # [-2, 1, -2, 4, 3, 2, 1, -5, 4]
    # [-2, 1, -2, 4, 3, 5, 1, -5, 4]
    # [-2, 1, -2, 4, 3, 5, 6, -5, 4]
    # [-2, 1, -2, 4, 3, 5, 6, 1, 4]
    # [-2, 1, -2, 4, 3, 5, 6, 1, 5]
print(max(nums))
